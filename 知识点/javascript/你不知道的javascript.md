# 第一部分  作用域和闭包
1.LHS  RHS
LHS: 赋值操作的目标是谁
RHS: 谁是赋值操作的源头
区分LHS和RHS是因为左变量还没有声明(任何情况都找不到该变量)的情况下，这两种查询的行为是不一样的
如果某一变量是未声明的变量，则
RHS: 抛出ReferenceError异常
LHS: 当程序运行在非严格模式下，则其会在全局作用域中创建一个该名称的变量

2.函数声明和函数表达式
区别: 它们的名称绑定则何处
函数声明： function  foo() {}  foo被绑定在所在的作用域中，可以直接通过foo()调用
函数表达式: (function foo(){...})()   foo被绑定在函数表达式自身的函数中而不是所在的作用域中，即foo只能在...所代表的位置中访问，外部
作用域不行。

3.提升
代码：
a = 2;
var a;
console.log(a);
最后输出2.
原因: js中包括变量和函数在内的所有声明都会在任何代码执行前首先被处理
因此  var a = 2;这段代码会被这样两步处理： var a; 和 a = 2;  第一个定义是在编译阶段进行，第二个赋值则是在执行阶段执行。因此上面的代码会
按如下形式处理：
var a;
a = 2;
console.log(a);
这样就感觉变量和函数声明从它们在代码中出现的位置被“移动”到了最上面，这个过程叫提升。
eg:
console.log(a);
var a = 2;
会输出： undefined
因为代码实际处理流程：
var a;
console.log(a);
a = 2;
