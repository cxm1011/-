# 1.阻塞非阻塞 同步异步

# 2.为什么setTimeOut精确度不高
实际上，setTimeout做的事情是：在指定delay时间后，将指定方法作为异步任务添加到异步任务队列中。

所以，如果setTimeout的定时到了执行时间，JS主线程仍然还在执行同步任务，setTimeout所指定的方法并不会立刻执行。
更惨的是，即使JS主线程执行完了同步任务，也不一定会执行setTimeout指定的方法，因为异步任务队列中可能有更早加入的异步任务。

最惨的是，即使天时地利人和，到了定时的时间时，JS主线程空闲，异步任务队列中只有setTimeout执行的方法，这个方法的执行时间也并不是精确的delay时间（精确到毫秒），因为浏览器上的计时器精确度有限：（以下摘自《Javascript高级程序设计（第三版）》）

IE8及更早版本的计时器精度为15.625ms
IE9及更晚版本的计时器精度为4ms
Firefox和Safari的计时器精度大约为10ms
Chrome的计时器精度为4ms

所以setTimeOut只能确保你的回调函数不会在指定的时间间隔进行，但可能会在那个时刻进行，也可能在那个时刻之后，要根据事件队列的状态而定

# 3.回调问题
回调最大的问题是控制反转，将代码控制权转给第三方了。它会导致信任链的完全断裂

# 4.函数防抖和节流入框连续输入进行AJAX验证时，用函数防抖能有效减
函数防抖(debounce)
概念： 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。
生活中的实例： 如果有人进电梯（触发事件），那电梯将在10秒钟后出发（执行事件监听器），这时如果又有人进电梯了（在10秒内再次触发该事件），我们又得等10秒再出发（重新计时）。
对于函数防抖，有以下几种应用场景：
给按钮加函数防抖防止表单多次提交。
对于输少请求次数。
判断scroll是否滑到底部，滚动事件+函数防抖
适合多次事件一次响应的情况


函数节流(throttle)
概念： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。
生活中的实例： 我们知道目前的一种说法是当 1 秒内连续播放 24 张以上的图片时，在人眼的视觉中就会形成一个连贯的动画，所以在电影的播放（以前是，现在不知道）中基本是以每秒 24 张的速度播放的，为什么不 100 张或更多是因为 24 张就可以满足人类视觉需求的时候，100 张就会显得很浪费资源。
对于函数节流，有如下几个场景：
游戏中的刷新率
DOM元素拖拽
Canvas画笔功能
总的来说，适合大量事件按时间做平均分配触发

